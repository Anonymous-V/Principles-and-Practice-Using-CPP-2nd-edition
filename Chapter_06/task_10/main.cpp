/*
 * Описание задачи:
 * ================
 * Перестановка - это упорядоченное подмножество некоторого множества. Например,
 * допустим, что вы хотите подобрать код к сейфу. Существует шестьдесят возможных
 * чисел, а вам необходимо выбрать три числа для комбинации. В этом случае существует
 * P(60, 3) перестановок, где количество перестановок определяется по формуле
 * P(a, b) = a!/(a - b)!, где символ ! означает факториал. Например, 4! - это
 * 4 * 3 * 2 * 1.
 *
 * Сочетания напоминают перестановки, с тем отличием, что в них
 * порядок следования элементов не имеет значения. Например, если вы делаете
 * слоистое мороженое и хотите использовать три разных вкуса из пяти, имеющихся в
 * наличии, вам все равно, когда вы используете мороженое - в начале или в конце, вы
 * просто хотите использовать его. Формула для вычисления количества сочетаний
 * имеет следующий вид: C(a, b) = P(a, b) / b!.
 *
 * Разработайте программу, запрашивающую у пользователя два числа и что для них
 * необходимо вычислить (количество перестановок или сочетаний), а также выводящую
 * требуемый результат на экран. Сначала выполните анализ перечисленных требований
 * к программе. Точно сформулируйте, что именно должна делать программа. Затем
 * переходите к этапу проектирования. Напишите псевдокод программы и разбейте его
 * на части. Программа должна выполнять проверку ошибок. Убедитесь, что все
 * неправильные входные данные приводят к появлению осмысленных сообщений об ошибках.
 *
 * Идея реализации:
 * ================
 * Первое, что необходимо сделать - это проверить входные данные.
 * Они должны соответствовать следующим условиям:
 * 1. Оба числа положительные
 * 2. A >= B
 * 3. Каждое из чисел не превышает 100 (на самом деле тип double вмещает 170 чисел
 *    из факториала, но я ограничился 100 числами)
 *
 * Если выполнились эти условия, то в других местах пред- и постусловия не нужны,
 * т.к. все предусловия уже выполнены, а ошибок в постусловиях не возникает.
 * Хотя, чтобы сделать функции более универсальные, можно было бы прописать для
 * каждой из них пред- и постусловия в них самих.
 *
 * Реализованы две функции факториала: одна принимает одно значение, другая - два.
 * Это сделано по той причине, что вычисления факториала можно сократить при
 * вычислении числа перестановок - по той причине, что числитель всегда больше или
 * равен знаменателю и если их разложить на множители, то в числителе останется
 * разница между числителем и знаменателем. Т.е. если были бы числа P(6, 3), то
 * формула была бы следующей: 6! / (6 - 3)! или (6! / 3!) или
 * (1 * 2 * 3 * 4 * 5 * 6) / (1 * 2 * 3) или (после сокращения соответствующих
 * множителей) 4 * 5 * 6.
 * */

#include "../../std_lib_facilities.h"

// Вычисление факториала от 1 до a
double factorial(int a) {
    int fact = 1;
    for (int i = 2; i <= a; ++i)
        fact *= i;
    return fact;
}

// Вычисление факториала от (a-b) до a
double factorial(int a, int b) {
    int fact = 1;
    for (int i = (a - b + 1); i <= a; ++i)
        fact *= i;
    return fact;
}

// Вычисление числа перестановок
double perm(int a, int b) {
    return factorial(a, b);
}

// Вычисление числа сочетаний
double comb(double a, int b) {
    return a / factorial(b);
}

// Проверка, что числа выполняют условия:
// 1. Оба числа положительные
// 2. A >= B
// 3. А <= 100 и B <= 100
bool check_nums(int a, int b) {
    // Максимальное значение числа
    const int MAX_VAL = 100;

    bool is_positive = a > 0 && b > 0;
    bool is_gr = a >= b;
    bool is_lt = (a <= MAX_VAL) && (b <= MAX_VAL);

    return is_positive && is_gr && is_lt;
}

int main() {
    try {
        int a, b;
        char sym;

        cout << "Enter the values A, B and the symbol 'p' or 'c':" << endl;
        cin >> a >> b >> sym;
        // Проверка входных данных
        if (!check_nums(a, b))
            throw runtime_error("The numbers must meet the following conditions:\n"
                                   "1. A > 0 and B > 0\n"
                                   "2. A >= B\n"
                                   "3. A <= 100 and B <= 100\n");

        switch (sym) {
            case 'p':
                cout << "P(a,b) == " << perm(a, b) << endl;
                break;
            case 'c':
                cout << "C(a,b) == " << comb( perm(a, b), b ) << endl;
                break;
            default:
                throw runtime_error("Valid character 'p' or 'c'");
        }

        return 0;
    } catch (runtime_error &e) {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
}